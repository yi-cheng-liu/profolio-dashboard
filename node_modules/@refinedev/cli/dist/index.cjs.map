{"version":3,"sources":["../src/index.ts","../src/definitions/projectTypes.ts","../src/definitions/uiFrameworks.ts","../src/definitions/package.ts","../src/utils/swizzle/import.ts","../src/utils/swizzle/appendAfterImports.ts","../src/utils/swizzle/getFileContent.ts"],"sourcesContent":["export * from \"./definitions/index.js\";\nexport { getImports, getNameChangeInImport } from \"./utils/swizzle/import.js\";\nexport { appendAfterImports } from \"./utils/swizzle/appendAfterImports.js\";\nexport { getFileContent } from \"./utils/swizzle/getFileContent.js\";\nexport type { ImportMatch, NameChangeMatch } from \"./utils/swizzle/import.js\";\n","export enum ProjectTypes {\n  REACT_SCRIPT = \"react-scripts\",\n  REMIX = \"remix\",\n  NEXTJS = \"nextjs\",\n  VITE = \"vite\",\n  CRACO = \"craco\",\n  PARCEL = \"parcel\",\n  UNKNOWN = \"unknown\",\n}\n","export enum UIFrameworks {\n  ANTD = \"antd\",\n  MUI = \"mui\",\n  MANTINE = \"mantine\",\n  CHAKRA = \"chakra-ui\",\n}\n","export enum PackageManagerTypes {\n  NPM = \"npm\",\n  YARN = \"yarn\",\n  PNPM = \"pnpm\",\n}\n\nexport type NpmOutdatedResponse = Record<\n  string,\n  {\n    current: string;\n    wanted: string;\n    latest: string;\n    dependet?: string;\n  }\n>;\n\nexport type RefinePackageInstalledVersionData = {\n  name: string;\n  current: string;\n  wanted: string;\n  latest: string;\n  changelog?: string;\n};\n","const packageRegex =\n  /import(?:(?:(?:[ \\n\\t]+([^ *\\n\\t\\{\\},]+)[ \\n\\t]*(?:,|[ \\n\\t]+))?([ \\n\\t]*\\{(?:[ \\n\\t]*[^ \\n\\t\"'\\{\\}]+[ \\n\\t]*,?)+\\})?[ \\n\\t]*)|[ \\n\\t]*\\*[ \\n\\t]*as[ \\n\\t]+([^ \\n\\t\\{\\}]+)[ \\n\\t]+)from[ \\n\\t]*(?:['\"])([^'\"\\n]+)(?:['\"])(?:;?)/g;\n\nconst nameChangeRegex = /((?:\\w|\\s|_)*)( as )((?:\\w|\\s|_)*)( |,)?/g;\n\nexport type ImportMatch = {\n  statement: string;\n  importPath: string;\n  defaultImport?: string;\n  namedImports?: string;\n  namespaceImport?: string;\n};\n\nexport type NameChangeMatch = {\n  statement: string;\n  fromName: string;\n  toName: string;\n  afterCharacter?: string;\n};\n\nexport const getImports = (content: string): Array<ImportMatch> => {\n  const matches = content.matchAll(packageRegex);\n\n  const imports: Array<ImportMatch> = [];\n\n  for (const match of matches) {\n    const [\n      statement,\n      defaultImport,\n      namedImports,\n      namespaceImport,\n      importPath,\n    ] = match;\n\n    imports.push({\n      statement,\n      importPath,\n      ...(defaultImport && { defaultImport }),\n      ...(namedImports && { namedImports }),\n      ...(namespaceImport && { namespaceImport }),\n    });\n  }\n\n  return imports?.filter(Boolean);\n};\n\nexport const getNameChangeInImport = (\n  namedImportString: string,\n): Array<NameChangeMatch> => {\n  const matches = namedImportString.matchAll(nameChangeRegex);\n\n  const nameChanges: Array<NameChangeMatch> = [];\n\n  for (const match of matches) {\n    const [statement, fromName, _as, toName, afterCharacter] = match;\n\n    nameChanges.push({\n      statement,\n      fromName: fromName.trim(),\n      toName: toName.trim(),\n      afterCharacter,\n    });\n  }\n\n  return nameChanges;\n};\n\n/** @internal */\nexport const getContentBeforeImport = (\n  content: string,\n  importMatch: ImportMatch,\n): string => {\n  // get the content before the import statement and between the last import statement and the current one\n  const contentBeforeImport = content.substring(\n    0,\n    content.indexOf(importMatch.statement),\n  );\n  // get the last import statement\n  const lastImportStatement = getImports(contentBeforeImport).pop();\n\n  // if there is no last import statement, return the content before the current import statement\n  if (!lastImportStatement) {\n    return contentBeforeImport;\n  }\n\n  // get the content between the last import statement and the current one\n  const contentBetweenImports = contentBeforeImport.substring(\n    contentBeforeImport.indexOf(lastImportStatement?.statement) +\n      lastImportStatement?.statement?.length,\n  );\n\n  // return the content before the current import statement and between the last import statement and the current one\n  return contentBetweenImports;\n};\n\n/** @internal */\nexport const isImportHasBeforeContent = (\n  content: string,\n  importMatch: ImportMatch,\n): boolean => {\n  const contentBeforeImport = importMatch\n    ? getContentBeforeImport(content, importMatch)\n    : \"\";\n\n  return !!contentBeforeImport.trim();\n};\n\nconst IMPORT_ORDER = [\"react\", \"@refinedev/core\", \"@refinedev/\"];\n\nexport const reorderImports = (content: string): string => {\n  let newContent = content;\n  // imports can have comments before them, we need to preserve those comments and import statements.\n  // so we need to filter out the imports with comments before.\n  const allImports = getImports(content);\n  // remove `import type` imports\n  const allModuleImports = allImports.filter(\n    (importMatch) => !importMatch.statement.includes(\"import type \"),\n  );\n  const typeImports = allImports.filter((importMatch) =>\n    importMatch.statement.includes(\"import type\"),\n  );\n\n  const importsWithBeforeContent: ImportMatch[] = [];\n  const importsWithoutBeforeContent: ImportMatch[] = [];\n\n  allModuleImports.forEach((importMatch) => {\n    if (isImportHasBeforeContent(content, importMatch)) {\n      importsWithBeforeContent.push(importMatch);\n    } else {\n      importsWithoutBeforeContent.push(importMatch);\n    }\n  });\n\n  // insertion point is the first import statement, others will be replaced to empty string and added to the first import line\n  const insertionPoint = newContent.indexOf(\n    importsWithoutBeforeContent?.[0]?.statement,\n  );\n\n  // remove all the imports without comments before\n  importsWithoutBeforeContent.forEach((importMatch) => {\n    newContent = newContent.replace(importMatch.statement, \"\");\n  });\n\n  // remove all type imports\n  typeImports.forEach((importMatch) => {\n    newContent = newContent.replace(importMatch.statement, \"\");\n  });\n\n  // we need to merge the imports from the same package unless one of them is a namespace import]\n  const importsByPackage = importsWithoutBeforeContent.reduce(\n    (acc, importMatch) => {\n      const { importPath } = importMatch;\n\n      if (acc[importPath]) {\n        acc[importPath].push(importMatch);\n      } else {\n        acc[importPath] = [importMatch];\n      }\n\n      return acc;\n    },\n    {} as Record<string, ImportMatch[]>,\n  );\n\n  // merge the imports from the same package\n  const mergedImports = Object.entries(importsByPackage).map(\n    ([importPath, importMatches]) => {\n      // example: A\n      const defaultImport = importMatches.find(\n        (importMatch) => importMatch.defaultImport,\n      );\n\n      // example: * as A\n      const namespaceImport = importMatches.find(\n        (importMatch) => importMatch.namespaceImport,\n      );\n\n      // example: { A, B }\n      // example: { A as C, B }\n      // content inside the curly braces should be merged\n      const namedImports = importMatches\n        .filter((importMatch) => importMatch.namedImports)\n        .map((importMatch) => {\n          // remove curly braces and trim then split by comma (can be multiline)\n          const namedImports = (importMatch.namedImports ?? \"\")\n            .replace(/{|}/g, \"\")\n            .trim()\n            .split(\",\")\n            .map((namedImport) => namedImport.trim());\n\n          return namedImports.filter(Boolean).join(\", \");\n        })\n        .join(\", \");\n\n      let importLine = \"\";\n\n      // default import and namespace import can not be used together\n      // but we can use default import and named imports together\n      // so we need to merge them\n      if (namespaceImport) {\n        importLine += `${namespaceImport.statement}\\n`;\n      }\n      if (defaultImport || namedImports) {\n        if (defaultImport && namedImports) {\n          importLine += `import ${defaultImport.defaultImport}, { ${namedImports} } from \"${importMatches[0].importPath}\";\\n`;\n        } else if (defaultImport) {\n          importLine += `import ${defaultImport.defaultImport} from \"${importMatches[0].importPath}\";\\n`;\n        } else {\n          importLine += `import { ${namedImports} } from \"${importMatches[0].importPath}\";\\n`;\n        }\n      }\n\n      return [importPath, importLine] as [\n        importPath: string,\n        importLine: string,\n      ];\n    },\n  );\n\n  // sort the imports without comments before\n  // sort should be done by IMPORT_ORDER and alphabetically\n  // priority is exact match in IMPORT_ORDER, then includes match in IMPORT_ORDER, then alphabetically\n  const sortedImports = [...mergedImports].sort(\n    ([aImportPath], [bImportPath]) => {\n      const aImportOrderIndex = IMPORT_ORDER.findIndex((order) =>\n        aImportPath.includes(order),\n      );\n      const bImportOrderIndex = IMPORT_ORDER.findIndex((order) =>\n        bImportPath.includes(order),\n      );\n\n      if (aImportOrderIndex === bImportOrderIndex) {\n        return aImportPath.localeCompare(bImportPath);\n      }\n\n      if (aImportOrderIndex === -1) {\n        return 1;\n      }\n\n      if (bImportOrderIndex === -1) {\n        return -1;\n      }\n\n      return aImportOrderIndex - bImportOrderIndex;\n    },\n  );\n\n  // add the sorted imports to the insertion point keep the before and after content\n  // add the type imports after the sorted imports\n  const joinedModuleImports = sortedImports\n    .map(([, importLine]) => importLine)\n    .join(\"\");\n  const joinedTypeImports = typeImports\n    .map((importMatch) => importMatch.statement)\n    .join(\"\\n\");\n\n  newContent =\n    newContent.substring(0, insertionPoint) +\n    joinedModuleImports +\n    joinedTypeImports +\n    newContent.substring(insertionPoint);\n\n  return newContent;\n};\n","import { getImports } from \"./import\";\n\nexport const appendAfterImports = (content: string, append: string): string => {\n  const imports = getImports(content);\n  const lastImport = imports[imports.length - 1];\n\n  const lastImportIndex = lastImport\n    ? content.indexOf(lastImport.statement)\n    : content.length - 1;\n\n  return `${content.slice(\n    0,\n    lastImportIndex + lastImport?.statement.length,\n  )}\\n${append}\\n${content.slice(\n    lastImportIndex + lastImport?.statement.length,\n  )}`;\n};\n","import { readFileSync } from \"fs-extra\";\nimport { join } from \"path\";\n\nexport function getFileContent(\n  this: undefined | { absolutePackageDir?: string },\n  path: string,\n): string | undefined {\n  if (!this?.absolutePackageDir) {\n    return undefined;\n  }\n  try {\n    return readFileSync(join(this.absolutePackageDir, path)).toString();\n  } catch (err) {\n    return undefined;\n  }\n}\n"],"mappings":"4ZAAA,IAAAA,EAAA,GAAAC,EAAAD,EAAA,yBAAAE,EAAA,iBAAAC,EAAA,iBAAAC,EAAA,uBAAAC,EAAA,mBAAAC,EAAA,eAAAC,EAAA,0BAAAC,IAAA,eAAAC,EAAAT,GCAO,IAAKU,OACVA,EAAA,aAAe,gBACfA,EAAA,MAAQ,QACRA,EAAA,OAAS,SACTA,EAAA,KAAO,OACPA,EAAA,MAAQ,QACRA,EAAA,OAAS,SACTA,EAAA,QAAU,UAPAA,OAAA,ICAL,IAAKC,OACVA,EAAA,KAAO,OACPA,EAAA,IAAM,MACNA,EAAA,QAAU,UACVA,EAAA,OAAS,YAJCA,OAAA,ICAL,IAAKC,OACVA,EAAA,IAAM,MACNA,EAAA,KAAO,OACPA,EAAA,KAAO,OAHGA,OAAA,ICAZ,IAAMC,EACJ,mOAEIC,EAAkB,4CAiBXC,EAAcC,GAAwC,CACjE,IAAMC,EAAUD,EAAQ,SAASH,CAAY,EAEvCK,EAA8B,CAAC,EAErC,QAAWC,KAASF,EAAS,CAC3B,GAAM,CACJG,EACAC,EACAC,EACAC,EACAC,CACF,EAAIL,EAEJD,EAAQ,KAAK,CACX,UAAAE,EACA,WAAAI,EACA,GAAIH,GAAiB,CAAE,cAAAA,CAAc,EACrC,GAAIC,GAAgB,CAAE,aAAAA,CAAa,EACnC,GAAIC,GAAmB,CAAE,gBAAAA,CAAgB,CAC3C,CAAC,EAGH,OAAOL,GAAA,YAAAA,EAAS,OAAO,QACzB,EAEaO,EACXC,GAC2B,CAC3B,IAAMT,EAAUS,EAAkB,SAASZ,CAAe,EAEpDa,EAAsC,CAAC,EAE7C,QAAWR,KAASF,EAAS,CAC3B,GAAM,CAACG,EAAWQ,EAAUC,EAAKC,EAAQC,CAAc,EAAIZ,EAE3DQ,EAAY,KAAK,CACf,UAAAP,EACA,SAAUQ,EAAS,KAAK,EACxB,OAAQE,EAAO,KAAK,EACpB,eAAAC,CACF,CAAC,EAGH,OAAOJ,CACT,EC/DO,IAAMK,EAAqB,CAACC,EAAiBC,IAA2B,CAC7E,IAAMC,EAAUC,EAAWH,CAAO,EAC5BI,EAAaF,EAAQA,EAAQ,OAAS,CAAC,EAEvCG,EAAkBD,EACpBJ,EAAQ,QAAQI,EAAW,SAAS,EACpCJ,EAAQ,OAAS,EAErB,MAAO,GAAGA,EAAQ,MAChB,EACAK,GAAkBD,GAAA,YAAAA,EAAY,UAAU,OAC1C;AAAA,EAAMH;AAAA,EAAWD,EAAQ,MACvBK,GAAkBD,GAAA,YAAAA,EAAY,UAAU,OAC1C,GACF,EChBA,IAAAE,EAA6B,oBAC7BC,EAAqB,gBAEd,SAASC,EAEdC,EACoB,CACpB,GAAK,iBAAM,mBAGX,GAAI,CACF,SAAO,mBAAa,QAAK,KAAK,mBAAoBA,CAAI,CAAC,EAAE,SAAS,CACpE,MAAE,CACA,MACF,CACF","names":["src_exports","__export","PackageManagerTypes","ProjectTypes","UIFrameworks","appendAfterImports","getFileContent","getImports","getNameChangeInImport","__toCommonJS","ProjectTypes","UIFrameworks","PackageManagerTypes","packageRegex","nameChangeRegex","getImports","content","matches","imports","match","statement","defaultImport","namedImports","namespaceImport","importPath","getNameChangeInImport","namedImportString","nameChanges","fromName","_as","toName","afterCharacter","appendAfterImports","content","append","imports","getImports","lastImport","lastImportIndex","import_fs_extra","import_path","getFileContent","path"]}